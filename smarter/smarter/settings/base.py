# pylint: disable=unused-wildcard-import, wildcard-import, unused-import, wrong-import-position
"""
Django base settings.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

import glob
import hashlib
import logging
import logging.config
import math
import os
import re
import secrets
import subprocess
import sys
import time
import urllib.parse
from pathlib import Path

from corsheaders.defaults import default_headers
from django import get_version
from social_core.backends.linkedin import LinkedinOAuth2

from smarter.__version__ import __version__ as smarter_version

# Add proprietary settings for the project
from .smarter import *  # noqa: E402, F401, W0401


logger = logging.getLogger(__name__)


# We implemented our own middleware to validate host names
ALLOWED_HOSTS = ["*"]
SMARTER_ALLOWED_HOSTS = []
LOCAL_HOSTS = smarter_settings.local_hosts
INTERNAL_IP_PREFIXES = ["192.168."]

# to disable redis/celery in collectstatic
if "collectstatic" in sys.argv:
    CELERY_TASK_ALWAYS_EAGER = True

CORS_ORIGIN_ALLOW_ALL = False
CORS_ALLOW_HEADERS = list(default_headers) + [
    "x-api-key",
]
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOWED_ORIGIN_REGEXES = [
    r"^https?://[\w-]+\.(\d+-\d+-\d+)\.api\.localhost:\d+$",
    r"^https?://[\w-]+\.localhost:\d+$",
    r"^https?://[\w-]\.api\.localhost:\d+$",
]
CORS_ALLOWED_ORIGINS = []

# -------------------------------
# Cross Site Request Forgery (CSRF) settings
# -------------------------------
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_NAME = "csrftoken"
CSRF_COOKIE_SAMESITE = "lax"
CSRF_COOKIE_AGE = 60 * 60 * 24
CSRF_COOKIE_DOMAIN = smarter_settings.environment_platform_domain
CSRF_COOKIE_PATH = "/"
CSRF_COOKIE_HTTPONLY = False
CSRF_HEADER_NAME = "HTTP_X_CSRFTOKEN"
CSRF_TRUSTED_ORIGINS = [
    smarter_settings.environment_platform_domain,
    smarter_settings.environment_api_domain,
]
CSRF_USE_SESSIONS = False


# -------------------------------
# Django session settings
# -------------------------------
# Whether to set the flag restricting cookie leaks on cross-site requests.
# This can be 'Lax', 'Strict', 'None', or False to disable the flag.
SESSION_COOKIE_SAMESITE = "lax"
SESSION_COOKIE_SECURE = False
SESSION_COOKIE_NAME = "sessionid"
SESSION_COOKIE_AGE = CSRF_COOKIE_AGE
SESSION_COOKIE_DOMAIN = smarter_settings.environment_platform_domain
SESSION_COOKIE_PATH = "/"
SESSION_COOKIE_HTTPONLY = True

SECURE_PROXY_SSL_HEADER = None

# -------------------------------
# Django storages settings for AWS S3
# -------------------------------
# See https://django-storages.readthedocs.io/en/latest/backends/amazon
STORAGES = {
    "default": {
        "BACKEND": "storages.backends.s3.S3Storage",
        "OPTIONS": {
            "access_key": smarter_settings.aws_access_key_id.get_secret_value(),
            "secret_key": smarter_settings.aws_secret_access_key.get_secret_value(),
            "bucket_name": smarter_settings.aws_s3_bucket_name,
            "region_name": smarter_settings.aws_region,
            "default_acl": "public-read",
            "querystring_auth": False,
        },
    },
    "staticfiles": {
        "BACKEND": "whitenoise.storage.CompressedStaticFilesStorage",
        "OPTIONS": {},
    },
}
DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
AWS_ACCESS_KEY_ID = smarter_settings.aws_access_key_id.get_secret_value()
AWS_SECRET_ACCESS_KEY = smarter_settings.aws_secret_access_key.get_secret_value()
AWS_STORAGE_BUCKET_NAME = smarter_settings.aws_s3_bucket_name
AWS_S3_REGION_NAME = smarter_settings.aws_region
AWS_QUERYSTRING_AUTH = False  # disable querystring auth for public files

# Build paths inside the project like this: BASE_DIR / 'subdir'.
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
BASE_DIR = Path(os.path.join(PROJECT_ROOT, "smarter")).resolve()

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

SECRET_KEY = smarter_settings.secret_key

if not SECRET_KEY:
    random_string = secrets.token_urlsafe(64)
    random_bytes = random_string.encode("utf-8")
    hash_object = hashlib.sha256(random_bytes)
    SECRET_KEY = hash_object.hexdigest()
    logger.warning("SECRET_KEY not set. Using randomized value: %s", SECRET_KEY)

logger.debug("PROJECT_ROOT: %s", PROJECT_ROOT)
logger.debug("BASE_DIR: %s", BASE_DIR)
logger.debug("SECRET_KEY: %s", SECRET_KEY)


DEBUG = smarter_settings.debug_mode

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://:smarter@smarter-redis:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
    }
}

SESSION_ENGINE = "django.contrib.sessions.backends.cache"

# Default Celery Configuration
CELERY_BROKER_URL = "redis://:smarter@smarter-redis:6379/1"
CELERY_TASK_TIME_LIMIT = 30 * 60

# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "storages",
    # smarter apps
    # -------------------------------
    "smarter.lib.drf",
    "smarter.lib.journal",
    "smarter.apps.account",
    "smarter.apps.api",
    "smarter.apps.chatbot",
    "smarter.apps.prompt",
    "smarter.apps.cms",
    "smarter.apps.dashboard",
    "smarter.apps.docs",
    "smarter.apps.plugin",
    "smarter.apps.provider",
    # 3rd party apps
    # -------------------------------
    "rest_framework",
    "knox",
    "taggit",
    "corsheaders",
    "drf_yasg",
    "django_celery_beat",
    "django.contrib.admindocs",
    "social_django",
    "waffle",
    # Wagtail
    # -------------------------------
    # see https://docs.wagtail.org/en/stable/advanced_topics/add_to_django_project.html
    "wagtail.contrib.forms",
    "wagtail.contrib.redirects",
    "wagtail.embeds",
    "wagtail.sites",
    "wagtail.users",
    "wagtail.snippets",
    "wagtail.documents",
    "wagtail.images",
    "wagtail.search",
    "wagtail.admin",
    "wagtail",
    "wagtail_transfer",
    # Stripe
    # -------------------------------
    # "djstripe",
]

MIDDLEWARE = [
    # this replaces corsheaders.middleware.CorsMiddleware"
    "smarter.lib.django.middleware.cors.CorsMiddleware",
    # this replaces django.middleware.security.SecurityMiddleware
    # simple middleware to block requests for common sensitive files
    # like .env, private key files, etc.
    # -------------------------------
    "smarter.lib.django.middleware.sensitive_files.BlockSensitiveFilesMiddleware",
    # to log and block excessive 404 errors, which is a growing problem
    # from botnets probing for vulnerabilities.
    # -------------------------------
    "smarter.lib.django.middleware.excessive_404.BlockExcessive404Middleware",
    #
    # -------------------------------
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "smarter.lib.drf.middleware.SmarterTokenAuthenticationMiddleware",
    "django.middleware.common.CommonMiddleware",
    # this replaces django.middleware.csrf.CsrfViewMiddleware
    # to add chatbot-specific CSRF handling
    # -------------------------------
    "smarter.lib.django.middleware.csrf.CsrfViewMiddleware",
    #
    # -------------------------------
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    # to manage ALLOWED_HOSTS
    # -------------------------------
    "smarter.apps.chatbot.middleware.security.SecurityMiddleware",
    #
    # -------------------------------
    # to ensure that all http responses are in json format
    # -------------------------------
    "smarter.lib.django.middleware.json.JsonErrorMiddleware",
    # -------------------------------
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "waffle.middleware.WaffleMiddleware",
    # wagtail middleware
    # -------------------------------
    "wagtail.contrib.redirects.middleware.RedirectMiddleware",
    "smarter.apps.cms.middleware.HTMLMinifyMiddleware",
    #
]

ROOT_URLCONF = "smarter.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [
            BASE_DIR / "templates",
        ],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "smarter.apps.account.context_processors.base",
                "smarter.apps.cms.context_processors.base",
                "smarter.apps.dashboard.context_processors.branding",
                "smarter.apps.dashboard.context_processors.base",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "wagtail.contrib.settings.context_processors.settings",
            ],
        },
    },
    {
        "NAME": "react",
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [
            BASE_DIR / "templates",
        ],
        "APP_DIRS": False,
        "OPTIONS": {
            "loaders": [
                "django.template.loaders.filesystem.Loader",
            ],
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "smarter.apps.account.context_processors.base",
                "smarter.apps.dashboard.context_processors.base",
            ],
        },
    },
]

WSGI_APPLICATION = "smarter.wsgi.application"

# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "NAME": "smarter",
        "USER": "smarter",
        "PASSWORD": "smarter",
        "HOST": "smarter-mysql",  # Or an IP Address that your DB is hosted on
        "PORT": "3306",
    }
}

# https://python-social-auth.readthedocs.io/en/latest/configuration/django.html
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTHENTICATION_BACKENDS = (
    "social_core.backends.google.GoogleOAuth2",
    "social_core.backends.github.GithubOAuth2",
    "smarter.lib.social_core.backends.linkedin.LinkedinOAuth2",
    "django.contrib.auth.backends.ModelBackend",
)

SOCIAL_AUTH_CREATE_USERS = False
SOCIAL_AUTH_PIPELINE = (
    # Get the information we can about the user and return it in a simple
    # format to create the user instance later. On some cases the details are
    # already part of the auth response from the provider, but sometimes this
    # could hit a provider API.
    "social_core.pipeline.social_auth.social_details",
    # Get the social uid from whichever service we're authing thru. The uid is
    # the unique identifier of the given user in the provider.
    "social_core.pipeline.social_auth.social_uid",
    # Verifies that the current auth process is valid within the current
    # project, this is where emails and domains whitelists are applied (if
    # defined).
    "social_core.pipeline.social_auth.auth_allowed",
    # Checks if the current social-account is already associated in the site.
    "social_core.pipeline.social_auth.social_user",
    # Make up a username for this person, appends a random string at the end if
    # there's any collision.
    "social_core.pipeline.user.get_username",
    # Send a validation email to the user to verify its email address.
    # 'social_core.pipeline.mail.mail_validation',
    # Associates the current social details with another user account with
    # a similar email address.
    "social_core.pipeline.social_auth.associate_by_email",
    # Create a user account if we haven't found one yet.
    "social_core.pipeline.user.create_user",
    # Create the record that associated the social account with this user.
    "social_core.pipeline.social_auth.associate_user",
    # Populate the extra_data field in the social record with the values
    # specified by settings (and the default ones like access_token, etc).
    "social_core.pipeline.social_auth.load_extra_data",
    # Update the user record with any changed info from the auth service.
    "social_core.pipeline.user.user_details",
)

SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = smarter_settings.social_auth_google_oauth2_key.get_secret_value()
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = smarter_settings.social_auth_google_oauth2_secret.get_secret_value()
SOCIAL_AUTH_GOOGLE_OAUTH2_REDIRECT_URI = urllib.parse.urljoin(
    smarter_settings.environment_url, "/social-auth/complete/google-oauth2/"
)

SOCIAL_AUTH_GITHUB_KEY = smarter_settings.social_auth_github_key.get_secret_value()
SOCIAL_AUTH_GITHUB_SECRET = smarter_settings.social_auth_github_secret.get_secret_value()

SOCIAL_AUTH_LINKEDIN_OAUTH2_KEY = smarter_settings.social_auth_linkedin_oauth2_key.get_secret_value()
SOCIAL_AUTH_LINKEDIN_OAUTH2_SECRET = smarter_settings.social_auth_linkedin_oauth2_secret.get_secret_value()
SOCIAL_AUTH_LINKEDIN_OAUTH2_SCOPE = ["openid", "profile", "email"]
SOCIAL_AUTH_LINKEDIN_OAUTH2_FIELD_SELECTORS = ["id", "first-name", "last-name", "email-address"]
SOCIAL_AUTH_LINKEDIN_OAUTH2_REDIRECT_URI = urllib.parse.urljoin(
    smarter_settings.environment_url, "/social-auth/complete/linkedin-oauth2/"
)
SOCIAL_AUTH_LINKEDIN_OAUTH2_EXTRA_DATA = [
    ("id", "id"),
    ("firstName", "first_name"),
    ("lastName", "last_name"),
    ("emailAddress", "email_address"),
]

SOCIAL_AUTH_ADMIN_USER_SEARCH_FIELDS = ["username", "first_name", "email"]
LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/"


# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/
LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/
STATIC_URL = "/static/"
STATIC_ROOT = PROJECT_ROOT / "staticfiles"

STATICFILES_DIRS = [BASE_DIR / "static"]
STATICFILES_STORAGE = "whitenoise.storage.CompressedStaticFilesStorage"

# ReactJS integration with Django. Add all reactapp/dist directories in Django apps
django_apps_dir = BASE_DIR / "apps"
reactapp_dirs = [Path(p) for p in glob.glob(os.path.join(django_apps_dir, "*", "reactapp", "dist"))]
STATICFILES_DIRS.extend(reactapp_dirs)

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "smarter.lib.drf.token_authentication.SmarterTokenAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
        "smarter.lib.drf.parsers.YAMLParser",
        "rest_framework.parsers.FormParser",
        "rest_framework.parsers.MultiPartParser",
    ],
}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "timestamped": {
            "format": "%(asctime)s - %(levelname)s - %(message)s",
            "datefmt": "[%Y-%m-%d %H:%M:%S %z]",
        },
    },
    "handlers": {
        "default": {
            "level": "INFO",
            "class": "logging.StreamHandler",
            "formatter": "timestamped",
        },
    },
    "root": {
        "handlers": ["default"],
        "level": "INFO",
    },
    "loggers": {
        "django.security.DisallowedHost": {
            "handlers": ["default"],
            "level": "ERROR",
            "propagate": False,
        },
    },
}
logging.config.dictConfig(LOGGING)

# https://dj-stripe.dev/dj-stripe/2.7/installation/
STRIPE_LIVE_SECRET_KEY = smarter_settings.stripe_live_secret_key
STRIPE_TEST_SECRET_KEY = smarter_settings.stripe_test_secret_key
STRIPE_LIVE_MODE = False  # Change to True in production
DJSTRIPE_WEBHOOK_SECRET = (
    "whsec_xxx"  # Get it from the section in the Stripe dashboard where you added the webhook endpoint
)
DJSTRIPE_USE_NATIVE_JSONFIELD = True  # We recommend setting to True for new installations
DJSTRIPE_FOREIGN_KEY_TO_FIELD = "id"

SENSITIVE_FILES_AMNESTY_PATTERNS = [
    re.compile(r"^/dashboard/account/password-reset-link/[^/]+/[^/]+/$"),
    re.compile(r"^/api(/.*)?$"),
    re.compile(r"^/admin(/.*)?$"),
    re.compile(r"^/plugin(/.*)?$"),
    re.compile(r"^/docs/manifest(/.*)?$"),
    re.compile(r"^/docs/json-schema(/.*)?$"),
    re.compile(r".*stackademy.*"),
]

SMTP_SENDER = smarter_settings.smtp_sender
SMTP_FROM_EMAIL = smarter_settings.smtp_from_email
SMTP_HOST = smarter_settings.smtp_host
SMTP_PASSWORD = smarter_settings.smtp_password
SMTP_PORT = smarter_settings.smtp_port
SMTP_USE_SSL = smarter_settings.smtp_use_ssl
SMTP_USE_TLS = smarter_settings.smtp_use_tls
SMTP_USERNAME = smarter_settings.smtp_username

WAFFLE_CREATE_MISSING_SWITCHES = True

# Wagtail settings
# This is the human-readable name of your Wagtail install
# which welcomes users upon login to the Wagtail admin.
WAGTAIL_SITE_NAME = "Smarter"

# Replace the search backend
# WAGTAILSEARCH_BACKENDS = {
#  'default': {
#    'BACKEND': 'wagtail.search.backends.elasticsearch8',
#    'INDEX': 'myapp'
#  }
# }

# Wagtail email notifications from address
WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = SMTP_FROM_EMAIL

# Wagtail email notification format
WAGTAILADMIN_NOTIFICATION_USE_HTML = True

# Allowed file extensions for documents in the document library.
# This can be omitted to allow all files, but note that this may present a security risk
# if untrusted users are allowed to upload files -
# see https://docs.wagtail.org/en/stable/advanced_topics/deploying.html#user-uploaded-files
WAGTAILDOCS_EXTENSIONS = ["csv", "docx", "key", "odt", "pdf", "pptx", "rtf", "txt", "xlsx", "zip"]

# Reverse the default case-sensitive handling of tags
TAGGIT_CASE_INSENSITIVE = True

WAGTAILADMIN_BASE_URL = "/cms/admin/"

WAGTAILTRANSFER_SOURCES = {
    "localhost": {
        "BASE_URL": "http://localhost:8000/wagtail-transfer/",
        "SECRET_KEY": "qr4hlujl144ye5hwn0k3f0no462ms81z",
    },
    "alpha": {
        "BASE_URL": "https://alpha.platform.smarter.sh/wagtail-transfer/",
        "SECRET_KEY": "1tv70boz9norbi2puxirls697j6v4x75",
    },
    "beta": {
        "BASE_URL": "https://beta.platform.smarter.sh/wagtail-transfer/",
        "SECRET_KEY": "rle5zr18w3igmsauc3pvu4uu9eo54egg",
    },
    "next": {
        "BASE_URL": "https://next.platform.smarter.sh/wagtail-transfer/",
        "SECRET_KEY": "3uy59hvdewlihhmee4duc5ytw277f34b",
    },
    "production": {
        "BASE_URL": "https://platform.smarter.sh/wagtail-transfer/",
        "SECRET_KEY": "q6ea0u8vt1u8eoprtxq5d9p5wae83fje",
    },
}

WAGTAILTRANSFER_SECRET_KEY = "8egf3jj8ib64j00gomz270wgzqwrfyed"
WAGTAILTRANSFER_CHOOSER_API_PROXY_TIMEOUT = 30

###############################################################################
# System information logging for all environments
###############################################################################
logger.info("=" * 80)

try:
    with open("/proc/uptime", encoding="utf-8") as f:
        uptime_seconds = float(f.readline().split()[0])
        uptime_str = time.strftime("%H:%M:%S", time.gmtime(uptime_seconds))
        logger.info("Container uptime: %s", uptime_str)
except FileNotFoundError:
    logger.warning("Container uptime not available")
except OSError as e:
    logger.error("Error reading container uptime: %s", e)

# try:
#     cpu_limit = int(subprocess.check_output("nproc", shell=True).decode().strip())
#     mem_total_line = subprocess.check_output("grep MemTotal /proc/meminfo", shell=True).decode().strip()
#     mem_kib = int(mem_total_line.split()[1])  # MemTotal value in kB
#     mem_gib = mem_kib / 1024 / 1024
#     logger.info("CPU limit: %s cores", cpu_limit)
#     if cpu_limit < 2:
#         logger.warning("Recommended minimum CPU limit is 2. Detected: %s cores", cpu_limit)
#     logger.info("Memory limit: %.2f GiB", mem_gib)
#     if mem_gib < 4.0:
#         logger.warning("Recommended minimum memory limit is 4 GiB. Detected: %.2f GiB", mem_gib)
# except (subprocess.CalledProcessError, OSError) as e:
#     logger.warning("Resource limits not available: %s", e)
# except (ValueError, IndexError) as e:
#     logger.error("Error parsing resource limits: %s", e)

try:
    # CPU limit (cgroup v2)
    cpu_limit = None
    cpu_max_path = "/sys/fs/cgroup/cpu.max"
    if os.path.exists(cpu_max_path):
        with open(cpu_max_path, encoding="utf-8") as f:
            quota, period = f.read().strip().split()
            if quota != "max":
                cpu_limit = math.ceil(int(quota) / int(period))
            else:
                cpu_limit = int(subprocess.check_output("nproc", shell=True).decode().strip())
    else:
        cpu_limit = int(subprocess.check_output("nproc", shell=True).decode().strip())

    # Memory limit (cgroup v2)
    mem_limit = None
    mem_max_path = "/sys/fs/cgroup/memory.max"
    if os.path.exists(mem_max_path):
        with open(mem_max_path, encoding="utf-8") as f:
            mem_bytes = int(f.read().strip())
            if mem_bytes < 1 << 60:  # If not unlimited
                mem_gib = mem_bytes / 1024 / 1024 / 1024
                mem_limit = mem_gib
            else:
                # Fallback to /proc/meminfo
                mem_total_line = subprocess.check_output("grep MemTotal /proc/meminfo", shell=True).decode().strip()
                mem_kib = int(mem_total_line.split()[1])
                mem_limit = mem_kib / 1024 / 1024
    else:
        mem_total_line = subprocess.check_output("grep MemTotal /proc/meminfo", shell=True).decode().strip()
        mem_kib = int(mem_total_line.split()[1])
        mem_limit = mem_kib / 1024 / 1024

    logger.info("CPU limit: %s cores", cpu_limit)
    if cpu_limit < 2:
        logger.warning("Recommended minimum CPU limit is 2. Detected: %s cores", cpu_limit)
    logger.info("Memory limit: %.2f GiB", mem_limit)
    if mem_limit < 4.0:
        logger.warning("Recommended minimum memory limit is 4 GiB. Detected: %.2f GiB", mem_limit)
except (OSError, subprocess.CalledProcessError) as e:
    logger.warning("Resource limits not available: %s", e)
except (ValueError, IndexError) as e:
    logger.error("Error parsing resource limits: %s", e)

try:
    debian_version = "not found"
    with open("/etc/debian_version", encoding="utf-8") as f:
        debian_version = f.read().strip()
    logger.info("Debian v%s %s", debian_version, os.uname().version)
except FileNotFoundError:
    logger.error("Debian version file not found")
except OSError as e:
    logger.error("Error reading Debian version: %s", e)

logger.info("Python v%s", sys.version)
logger.info("Django v%s", get_version())
logger.info("Smarter v%s", smarter_version)
logger.info("=" * 80)
